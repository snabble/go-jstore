package elastic

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/olivere/elastic"
	"github.com/pkg/errors"
	"github.com/snabble/go-jstore"
)

var DriverName = "elastic"

// IndexNamer is a strategy to name the indexes used by the
// store. This can be used to store documents in in date based
// indicies.
//
// If matchAll is true, the namer should return a index pattern that
// matches all index names generated by him. For details see:
//
// https://www.elastic.co/guide/en/elasticsearch/reference/current/multi-index.html
type IndexNamer func(project, documentType string, matchAll bool) string

type ElasticStoreOption func(store *ElasticStore) error

// IndexName allows to insert a custom IndexNamer
func IndexName(provider IndexNamer) ElasticStoreOption {
	return func(store *ElasticStore) error {
		store.indexName = provider
		return nil
	}
}

func DefaultIndexName() ElasticStoreOption {
	return func(store *ElasticStore) error {
		store.indexName = defaultIndexName
		return nil
	}
}

func SyncUpdates() ElasticStoreOption {
	return func(store *ElasticStore) error {
		store.syncUpdates = true
		return nil
	}
}

func IndexTemplate(name string, template interface{}) ElasticStoreOption {
	return func(store *ElasticStore) error {
		response, err := store.client.IndexPutTemplate(name).
			BodyJson(template).
			Do(store.cntx())

		if err != nil {
			return err
		}

		if !response.Acknowledged {
			return errors.Errorf("creation of index template %s not acknowledged", name)
		}
		return nil
	}
}

func init() {
	provider := func(baseURL string, options ...jstore.StoreOption) (jstore.Store, error) {
		return NewElasticStore(baseURL, options...)
	}
	jstore.RegisterProvider(DriverName, provider)
}

type ElasticStore struct {
	client      *elastic.Client
	syncUpdates bool
	indexName   IndexNamer
}

func NewElasticStore(baseURL string, options ...jstore.StoreOption) (*ElasticStore, error) {
	clientOptions := []elastic.ClientOptionFunc{elastic.SetURL(baseURL)}
	for _, option := range options {
		if clientOption, ok := option.(elastic.ClientOptionFunc); ok {
			clientOptions = append(clientOptions, clientOption)
		}
	}

	client, err := elastic.NewClient(clientOptions...)
	if err != nil {
		return nil, err
	}

	store := &ElasticStore{
		client:      client,
		syncUpdates: false,
		indexName:   defaultIndexName,
	}

	for _, option := range options {
		if esOption, ok := option.(ElasticStoreOption); ok {
			if err := esOption(store); err != nil {
				return nil, err
			}
		}
	}

	return store, nil
}

func (store *ElasticStore) HealthCheck() error {
	cntx, cancelFunc := context.WithTimeout(store.cntx(), time.Second)
	defer cancelFunc()
	resp, err := store.client.ClusterHealth().
		Do(cntx)
	if err != nil {
		return errors.Wrap(err, "elasticsearch health")
	}
	if resp.Status != "green" && resp.Status != "yellow" {
		return errors.Errorf("elasticsearch health status is %v", resp.Status)
	}
	return nil
}

func (store *ElasticStore) Delete(id jstore.EntityID) error {
	query := store.client.Delete().
		Index(store.indexName(id.Project, id.DocumentType, false)).
		Type(id.DocumentType).
		Id(id.ID)

	if id.Version != jstore.NoVersion {
		query.Version(id.Version)
	}

	if store.syncUpdates {
		query = query.Refresh("true")
	}

	_, err := query.Do(store.cntx())

	if err != nil {
		if e, ok := err.(*elastic.Error); ok && e.Details != nil && e.Details.Type == "version_conflict_engine_exception" {
			return jstore.OptimisticLockingError
		}
		return errors.Wrapf(err, "deleting entity %v", id)
	}

	return err
}

func (store *ElasticStore) Save(id jstore.EntityID, json string) (jstore.EntityID, error) {
	query := store.client.Index().
		Index(store.indexName(id.Project, id.DocumentType, false)).
		Type(id.DocumentType).
		Id(id.ID).
		BodyString(json)

	if id.Version != jstore.NoVersion {
		query.Version(id.Version)
	}

	if store.syncUpdates {
		query = query.Refresh("true")
	}

	resp, err := query.Do(store.cntx())

	if err != nil {
		if e, ok := err.(*elastic.Error); ok && e.Details.Type == "version_conflict_engine_exception" {
			return jstore.EntityID{}, jstore.OptimisticLockingError
		}
		return id, err
	}

	return jstore.EntityID{
		Project:      id.Project,
		DocumentType: id.DocumentType,
		ID:           resp.Id,
		Version:      resp.Version,
	}, nil
}

func (store *ElasticStore) Get(id jstore.EntityID) (jstore.Entity, error) {
	return store.Find(id.Project, id.DocumentType, jstore.Id(id.ID))
}

func (store *ElasticStore) Find(project, documentType string, options ...jstore.Option) (jstore.Entity, error) {
	search, err := store.createSearch(project, documentType, options...)
	if err != nil {
		return jstore.Entity{}, err
	}

	resp, err := search.Size(1).Do(store.cntx())

	if err != nil {
		if e, ok := err.(*elastic.Error); ok && e.Details != nil &&
			(e.Details.Type == "index_not_found_exception" || e.Details.Reason == "no such index") {
			return jstore.Entity{}, jstore.NotFound
		}
		return jstore.Entity{}, err
	}

	if resp.TotalHits() <= 0 {
		return jstore.Entity{}, jstore.NotFound
	}

	return toEntity(project, documentType, resp.Hits.Hits[0]), nil
}

func (store *ElasticStore) FindN(project, documentType string, maxCount int, options ...jstore.Option) ([]jstore.Entity, error) {
	search, err := store.createSearch(project, documentType, options...)
	if err != nil {
		return nil, err
	}

	resp, err := search.Size(maxCount).Do(store.cntx())
	if err != nil {
		if e, ok := err.(*elastic.Error); ok &&
			(e.Details.Type == "index_not_found_exception" ||
				e.Details.Reason == "no such index") {
			return nil, jstore.NotFound
		}
		return nil, err
	}

	results := make([]jstore.Entity, 0, resp.TotalHits())
	for _, h := range resp.Hits.Hits {
		results = append(results, toEntity(project, documentType, h))
	}
	return results, nil
}

func (store *ElasticStore) SearchIn(project, documentType string) *elastic.SearchService {
	return store.client.
		Search(store.indexName(project, documentType, true)).
		Type(documentType)
}

func (store *ElasticStore) cntx() context.Context {
	return context.Background()
}

func toEntity(project, documentType string, hit *elastic.SearchHit) jstore.Entity {
	return jstore.Entity{
		EntityID:  toEntityID(project, documentType, hit),
		ObjectRef: nil,
		JSON:      string(*hit.Source),
	}
}

func toEntityID(project, documentType string, hit *elastic.SearchHit) jstore.EntityID {
	return jstore.EntityID{
		Project:      project,
		DocumentType: documentType,
		ID:           hit.Id,
		Version:      *hit.Version,
	}
}

func (store *ElasticStore) createSearch(project, documentType string, options ...jstore.Option) (*elastic.SearchService, error) {
	boolQuery := elastic.NewBoolQuery()
	for _, o := range options {
		switch o := o.(type) {
		case jstore.IdOption:
			boolQuery.Must(elastic.NewIdsQuery().Ids(o.Value))
		case jstore.CompareOption:
			switch o.Operation {
			case "=":
				boolQuery.Must(elastic.NewTermQuery(o.Property, o.Value))
			case "<":
				boolQuery.Must(elastic.NewRangeQuery(o.Property).Lt(o.Value))
			case "<=":
				boolQuery.Must(elastic.NewRangeQuery(o.Property).Lte(o.Value))
			case ">":
				boolQuery.Must(elastic.NewRangeQuery(o.Property).Gt(o.Value))
			case ">=":
				boolQuery.Must(elastic.NewRangeQuery(o.Property).Gte(o.Value))
			default:
				return nil, errors.New("unsupported compare option: " + o.Operation)
			}
		default:
			return nil, errors.Errorf("unsupported option: %v", o)
		}
	}

	return store.SearchIn(project, documentType).
		Version(true).
		Query(boolQuery), nil
}

func defaultIndexName(project, documentType string, _ bool) string {
	return strings.ToLower(project + "-" + documentType)
}

func DailyIndexNamer(project, documentType string, matchAll bool) string {
	return dailyIndexNamer(time.Now)(project, documentType, matchAll)
}

func dailyIndexNamer(timeSourceFunc func() time.Time) IndexNamer {
	return func(project, documentType string, matchAll bool) string {
		prefix := fmt.Sprintf("%s-%s-", project, strings.ToLower(documentType))
		suffix := "*"
		if !matchAll {
			suffix = timeSourceFunc().UTC().Format("2006.01.02")
		}
		return prefix + suffix
	}
}
